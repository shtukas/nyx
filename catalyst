#!/usr/bin/ruby

# encoding: UTF-8

require 'json'

require 'date'

require 'colorize'

require 'securerandom'
# SecureRandom.hex    #=> "eb693ec8252cd630102fd0d0fb7c3485"
# SecureRandom.hex(4) #=> "eb693123"
# SecureRandom.uuid   #=> "2d931510-d99f-494a-8c67-87feb05e1594"

require "/Galaxy/local-resources/Ruby-Libraries/LucilleCore.rb"

require 'fileutils'
# FileUtils.mkpath '/a/b/c'
# FileUtils.cp(src, dst)
# FileUtils.mv 'oldname', 'newname'
# FileUtils.rm(path_to_image)
# FileUtils.rm_rf('dir/to/remove')

require_relative "CatalystObjects.rb"

require_relative "Wave-Emails.rb"

require "/Galaxy/local-resources/Ruby-Libraries/KeyValueStore.rb"
=begin
    KeyValueStore::set(repositorypath or nil, key, value)
    KeyValueStore::getOrNull(repositorypath or nil, key)
    KeyValueStore::getOrDefaultValue(repositorypath or nil, key, defaultValue)
    KeyValueStore::destroy(repositorypath or nil, key)
=end

require "/Galaxy/LucilleOS/Librarian/Librarian-Exported-Functions.rb"

require 'digest/sha1'
# Digest::SHA1.hexdigest 'foo'
# Digest::SHA1.file(myFile).hexdigest

require 'find'

# ----------------------------------------------------------------------

# Jupiter::isInteger(str)
# Jupiter::emailSyncOnSchedule(verbose)
# Jupiter::screenHeight()
# Jupiter::screenWidth()
# Jupiter::doExecute(object, expression)
# Jupiter::putshelp()
# Jupiter::editTextUsingTextmate(text)
# Jupiter::processItemDescriptionPossiblyAsTextEditorInvitation(description)
# Jupiter::codeToDatetimeOrNull(code)
# Jupiter::object2Line_v0(object)
# Jupiter::object2Line_v1(object)
# Jupiter::interactiveDisplayObjectAndProcessCommand(object)
# Jupiter::selectDisplayObjects()
# Jupiter::takeWorkspaceSizeOrUpToFirstNewObject(workspaceSize, previousObjects, allObjectsLeft, allObjectsSelected = [])
# Jupiter::main2()

class Jupiter
    def self.isInteger(str)
        str.to_i.to_s == str
    end

    def self.emailSyncOnSchedule(verbose)
        if LucilleCore::trueNoMoreOftenThanNEverySeconds("29a504de-7985-493b-b809-332357bda3a7", 1200) then
            begin
                newEmailCount = GeneralEmailClient::syncEmailDataWithServer(JSON.parse(IO.read("/Galaxy/DataBank/Catalyst/Wave/Wave-Email-Config/guardian-relay.json")), verbose)
                if newEmailCount>0 then
                    #puts "Retrieved #{newEmailCount} new emails"
                end
                OperatorEmailDownloader::syncEmailDataWithServer(JSON.parse(IO.read("/Galaxy/DataBank/Catalyst/Wave/Wave-Email-Config/operator.json")), verbose)
                # We call again so that the clock restarts at the end of the process
                LucilleCore::trueNoMoreOftenThanNEverySecondsReset("29a504de-7985-493b-b809-332357bda3a7")
            rescue
            end
        end    
    end

    def self.screenHeight()
        `/usr/bin/env tput lines`.to_i
    end

    def self.screenWidth()
        `/usr/bin/env tput cols`.to_i
    end

    def self.doExecute(object, expression)

        if expression == 'help' then
            Jupiter::putshelp()
            LucilleCore::pressEnterToContinue()
            return
        end

        if expression == '!today' then
            TodayOrNotToday::notToday(object["uuid"])
            return
        end

        if expression == 'top' then
            loop {
                selectedobject = LucilleCore::interactivelySelectEntityFromListOfEntitiesOrNull("object", Jupiter::selectDisplayObjects().first(Jupiter::screenHeight()-3), lambda{ |object| Jupiter::object2Line_v0(object) })
                break if selectedobject.nil?
                Jupiter::interactiveDisplayObjectAndProcessCommand(selectedobject)
            }
            return
        end

        if expression == 'clear' then
            system("clear")
            return
        end

        if expression == 'expose' then
            puts JSON.pretty_generate(object)
            LucilleCore::pressEnterToContinue()
            return
        end

        if expression == 'info' then
            puts "WaveDevOps::getArchiveSizeInMegaBytes(): #{WaveDevOps::getArchiveSizeInMegaBytes()}".green
            puts "Todolists".green
            puts "    Stream:".green
            puts "        count: #{( count1 = Stream::getUUIDs().size )}".green
            puts "        hours: #{StreamGlobalDataBaseInterface::getStreamTotalTimeInSecondsLastWeek().to_f/3600}".green
            puts "        multiplier: #{Math.exp(-StreamGlobalDataBaseInterface::getStreamTotalTimeInSecondsLastWeek().to_f/(3600*10))}".green
            puts "    x-laniakea count: #{( count2 = FIFOQueue::values(nil, "2477F469-6A18-4CAF-838A-E05703585A28").count )}".green
            puts "    vienna count: #{(count3 = Vienna::getUnreadLinks().count)}".green
            puts "Todolists total count: #{(count1+count2+count3)}".green
            puts "REQUIREMENTS OFF: #{RequirementsOperator::currentlyUnsatisfifiedRequirements().join(", ")}".green
            LucilleCore::pressEnterToContinue()
            return
        end

        if expression == 'lib' then
            LibrarianExportedFunctions::librarianUserInterface_librarianInteractive()
            return
        end

        if expression.start_with?("r:show") then
            requirement = expression[6, expression.size].strip
            if requirement.size==0 then
                requirement = RequirementsOperator::selectExistingRequirement()
            end
            loop {
                requirementObjects = CatalystObjects::all().select{ |object| RequirementsOperator::getObjectRequirements(object['uuid']).include?(requirement) }
                selectedobject = LucilleCore::interactivelySelectEntityFromListOfEntitiesOrNull("object", requirementObjects, lambda{ |object| Jupiter::object2Line_v0(object) })
                break if selectedobject.nil?
                Jupiter::interactiveDisplayObjectAndProcessCommand(selectedobject)
            }
            return
        end

        if expression.start_with?("c:show") then
            collection = expression[6, expression.size].strip
            if collection.size==0 then
                collection = Collections::selectExistingCollection()
            end
            loop {
                uuids = Collections::getCollectionUUIDs(collection)
                objects = CatalystObjects::all().select{|object| uuids.include?(object["uuid"]) }
                selectedobject = LucilleCore::interactivelySelectEntityFromListOfEntitiesOrNull("object", objects, lambda{ |object| Jupiter::object2Line_v0(object) })
                break if selectedobject.nil?
                Jupiter::interactiveDisplayObjectAndProcessCommand(selectedobject)
            }
            return
        end

        if expression.start_with?("c:add")  then
            collection = expression[5, expression.size].strip
            if collection.size==0 then
                collection = Collections::selectExistingOrNewCollection()
            end
            Collections::addObjectToCollection(object["uuid"], collection)
            return
        end

        if expression.start_with?('+') then
            code = expression
            if (datetime = Jupiter::codeToDatetimeOrNull(code)) then
                DoNotShowUntil::set(object["uuid"], datetime)
            end
            return
        end

        if expression.start_with?('wave:') then
            description = expression[5, expression.size].strip
            description = Jupiter::processItemDescriptionPossiblyAsTextEditorInvitation(description)
            uuid = SecureRandom.hex(4)
            schedule = WaveSchedules::makeScheduleObjectInteractivelyOrNull()
            folderpath = WaveTimelineUtils::timestring22ToFolderpath(LucilleCore::timeStringL22())
            FileUtils.mkpath folderpath
            File.open("#{folderpath}/catalyst-uuid", 'w') {|f| f.write(uuid) }
            File.open("#{folderpath}/catalyst-description.txt", 'w') {|f| f.write(description) }
            WaveTimelineUtils::writeScheduleToDisk(uuid, schedule)
            if schedule["@"]=="new" then
                code = LucilleCore::askQuestionAnswerAsString("datecode (or empty): ")
                if (datetime = Jupiter::codeToDatetimeOrNull(code)) then
                    DoNotShowUntil::set(uuid, datetime)
                end
            end
            return
        end

        if expression.start_with?('stream:') then
            description = expression[7, expression.size].strip
            description = Jupiter::processItemDescriptionPossiblyAsTextEditorInvitation(description)
            folderpath = "#{CATALYST_COMMON_PATH_TO_STREAM_DOMAIN_FOLDER}/strm2/#{LucilleCore::timeStringL22()}"
            FileUtils.mkpath folderpath
            File.open("#{folderpath}/description.txt", 'w') {|f| f.write(description) }
            puts "created item: #{folderpath}"
            return
        end

        if expression.start_with?("search") then
            pattern = expression[6,expression.size].strip
            loop {
                searchobjects = CatalystObjects::all().select{|object| Jupiter::object2Line_v0(object).downcase.include?(pattern.downcase) }
                break if searchobjects.size==0
                selectedobject = LucilleCore::interactivelySelectEntityFromListOfEntitiesOrNull("object", searchobjects, lambda{ |object| Jupiter::object2Line_v0(object) })
                break if selectedobject.nil?
                Jupiter::interactiveDisplayObjectAndProcessCommand(selectedobject)
            }
            return
        end

        if expression.start_with?("r:add") then
            requirement = expression[7,expression.size].strip
            RequirementsOperator::addObjectRequirement(object['uuid'],requirement)
            return
        end

        if expression.start_with?("r:remove") then
            requirement = expression[9,expression.size].strip
            RequirementsOperator::removeObjectRequirement(object['uuid'],requirement)
            return
        end

        if expression.start_with?("on") then
            command, requirement = expression.split(" ")
            RequirementsOperator::setRequirementOn(requirement)
            return
        end

        if expression.start_with?("off") then
            command, requirement = expression.split(" ")    
            RequirementsOperator::setRequirementOff(requirement)
            return
        end

        if expression.size > 0 then
            tokens = expression.split(" ").map{|t| t.strip }
            .each{|token| object['command-interpreter'].call(object, token) }
        else
            object['command-interpreter'].call(object, "")
        end
    end

    def self.putshelp()
        puts "Special General Commands (view)"
        puts "    help"
        puts "    top"
        puts "    search <pattern>"
        puts "    r:show [requirement] # optional parameter # shows all the objects of that requirement"
        puts "    c:show [collection]  # optional parameter # shows all the objects of that collection"
        puts ""
        puts "Special General Commands (inserts)"
        puts "    wave: <wave description>"
        puts "    stream: <stream description>"
        puts ""
        puts "Special General Commands (special circumstances)"
        puts "    clear # clear the screen"
        puts "    lib # Invoques the Librarian interactive"
        puts "    on <requirement>"
        puts "    off <requirement> <number of hours>"
        puts ""
        puts "Special Object Commands:"
        puts "    expose # print the object"
        puts "    !today"
        puts "    r:add <requirement>"
        puts "    r:remove <requirement>"
        puts "    c:add [collection] # optional parameter # send to a collection"
        puts "    command ..."
        puts "    (+)datetimecode"
    end

    def self.editTextUsingTextmate(text)
      filename = SecureRandom.hex
      filepath = "/tmp/#{filename}"
      File.open(filepath, 'w') {|f| f.write(text)}  
      system("/usr/local/bin/mate \"#{filepath}\"")
      print "> press enter when done: "
      input = STDIN.gets
      IO.read(filepath)  
    end

    def self.processItemDescriptionPossiblyAsTextEditorInvitation(description)
        if description=='text' then
            editTextUsingTextmate("")
        else
            description
        end
    end

    def self.codeToDatetimeOrNull(code)
        localsuffix = Time.new.to_s[-5,5]
        if code[0,1]=='+' then
            code = code[1,999]
            if code.index('@') then
                # The first part is an integer and the second HH:MM
                part1 = code[0,code.index('@')]
                part2 = code[code.index('@')+1,999]
                "#{( DateTime.now + part1.to_i ).to_date.to_s} #{part2}:00 #{localsuffix}"
            else
                if code.include?('days') or code.include?('day') then
                    if code.include?('days') then
                        # The entire string is to be interpreted as a number of days from now
                        "#{( DateTime.now + code[0,code.size-4].to_f ).to_time.to_s}"
                    else
                        # The entire string is to be interpreted as a number of days from now
                        "#{( DateTime.now + code[0,code.size-3].to_f ).to_time.to_s}"
                    end

                elsif code.include?('hours') or code.include?('hour') then
                    if code.include?('hours') then
                        ( Time.new + code[0,code.size-5].to_f*3600 ).to_s
                    else
                        ( Time.new + code[0,code.size-4].to_f*3600 ).to_s
                    end
                else
                    nil
                end
            end
        else
            # Here we expect "YYYY-MM-DD" or "YYYY-MM-DD@HH:MM" 
            if code.index('@') then
                part1 = code[0,10]
                part2 = code[11,999]
                "#{part1} #{part2}:00 #{localsuffix}"
            else
                part1 = code[0,10]
                part2 = code[11,999]
                "#{part1} 00:00:00 #{localsuffix}"
            end
        end
    end

    def self.object2Line_v0(object)
        doNotShowUntilAsString = object["do-not-show-until-datetime"] ? " (do not show until: #{object["do-not-show-until-datetime"]})" : ""
        [
            "(#{"%.3f" % object["metric"]})",
            " [#{object["uuid"]}]",
            " #{object['announce'].lines.first.strip}",
            "#{doNotShowUntilAsString}",
        ].join()
    end

    def self.object2Line_v1(object)
        defaultExpressionAsString = object["default-expression"] ? object["default-expression"] : ""
        requirements = RequirementsOperator::getObjectRequirements(object['uuid'])
        requirementsAsString = requirements.size>0 ? " ( #{requirements.join(" ")} )" : ''
        doNotShowUntilAsString = object["do-not-show-until-datetime"] ? " (do not show until: #{object["do-not-show-until-datetime"]})" : ""
        [
            "(#{"%.3f" % object["metric"]})",
            " [#{object["uuid"]}]",
            " #{object['announce'].strip}",
            "#{requirementsAsString.green}",
            "#{doNotShowUntilAsString}",
            " (#{object["commands"].join(" ").red})",
            " \"#{defaultExpressionAsString.green}\""
        ].join()
    end

    def self.interactiveDisplayObjectAndProcessCommand(object)
        print Jupiter::object2Line_v1(object) + " : "
        givenCommand = STDIN.gets().strip
        command = givenCommand.size>0 ? givenCommand : ( object["default-expression"] ? object["default-expression"] : "" )
        Jupiter::doExecute(object, command)
    end

    def self.selectDisplayObjects()
        objects = CatalystObjects::all()
            .select{|object| TodayOrNotToday::todayOk(object["uuid"]) }
            .select{|object| RequirementsOperator::meetRequirements(object["uuid"]) }
            .select{|object| Collections::objectIsNotInAnyCollection(object["uuid"]) }
            .select{|object| object["metric"] >= 0.2 }
        DoNotShowUntil::transform(objects)
            .sort{|o1,o2| o1['metric']<=>o2['metric'] }
            .reverse
    end

    def self.main2()
        workspaceSize = 1
        loop {
            WaveDevOps::archivesGarbageCollection(true)
            objects = Jupiter::selectDisplayObjects()
            objects = objects.take(workspaceSize)
            system("clear")
            puts "REQUIREMENTS OFF: #{RequirementsOperator::currentlyUnsatisfifiedRequirements().join(", ")}".yellow
            puts "COLLECTIONS     : #{Collections::getCollections().join(", ")}".yellow
            selectedObject = objects.last
            objects.each{|object|
                string =
                    if object["uuid"]==selectedObject["uuid"] then
                        "[*] #{Jupiter::object2Line_v1(object)}"
                    else
                        "    #{Jupiter::object2Line_v0(object)}"
                    end
                string =
                    if object["metric"]>1 then
                        string.green
                    else
                        string
                    end
                puts string
            }
            object = selectedObject
            puts ""
            print "--> "
            givenCommand = STDIN.gets().strip
            if givenCommand=="+" then
                workspaceSize = workspaceSize+1
                next
            end
            if givenCommand=="-" then
                workspaceSize = [workspaceSize-1, 1].max
                next
            end
            if Jupiter::isInteger(givenCommand) then
                workspaceSize = [givenCommand.to_i, 1].max
                next
            end
            if givenCommand.start_with?(":") then
                suffix = givenCommand[1,givenCommand.size]
                if Jupiter::isInteger(suffix) then
                    object = objects.drop(suffix.to_i-1).first
                    if object then
                        Jupiter::interactiveDisplayObjectAndProcessCommand(object)
                    end
                end
                next
            end
            if givenCommand=="." then
                givenCommand = object["default-expression"] ? object["default-expression"] : ""
            end
            Jupiter::doExecute(object, givenCommand)
        }
    end
end

# -----------------------------------------------------------------

RequirementsOperator::init()
DoNotShowUntil::init()
Collections::init()

# -----------------------------------------------------------------

Thread.new { 
    sleep 6
    Jupiter::emailSyncOnSchedule(false)
    loop {
        sleep 1200
        Jupiter::emailSyncOnSchedule(false)
    }
}

Jupiter::main2()
